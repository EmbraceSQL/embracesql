// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CLI generates an embedded client 1`] = `
"import {
  buildInternalContext,
  loadConfiguration,
  InternalContext,
  withTransaction,
} from \\"@embracesql/engine\\";
import * as types from \\"./context\\";

type EmbeddedEngine = types.HasEntryPoints &
  types.SQLModuleTree &
  types.HasConfiguration;

// each SQL Module has a direct execution decorator  -- this just talks to the database
// this attaches handlers both before and after wrapping the direct executor
// this ends up being a decorated map of handler+query execution capability
// autocrud is a little different, there are no handlers to load up from disk
// so this is a strong type wrapping
export const decorateWithHandlers = (rootContext: InternalContext) => {
  return {
    // database default
    default_hello: async (
      context: types.default_helloContext
    ): Promise<types.default_helloContext> => {
      const { afterError } = require(\\"./default/hello.sql.afterError\\");
      try {
        const before0 = require(\\"./default/before\\").before;
        await before0(context);
        const before = require(\\"./default/hello.sql.before\\").before;
        await before(context);
        const executor = rootContext.sqlModuleExecutors.default_hello.executor;
        const results = executor ? (await executor(context)).results : [];
        context.results = results as types.default_helloRow[];
        const after = require(\\"./default/hello.sql.after\\").after;
        await after(context);
        const after0 = require(\\"./default/after\\").after;
        await after0(context);
        return context;
      } catch (error) {
        context.error = error;
        if (afterError) afterError(context);
        throw error;
      }
    },
  };
};

// transaction wrappings very near the outside on each call
// this the the first 'real' execution layer
// so like - embedded engine -> entry point -> transactionwrapped
export const decorateWithTransactions = (
  rootContext: InternalContext,
  innerExecutors: types.ExecutorMap
) => {
  return {
    // database default
    default_hello: async (
      context: types.default_helloContext
    ): Promise<types.default_helloContext> => {
      return withTransaction(
        rootContext.databases.default,
        innerExecutors.default_hello,
        context
      );
    },
  };
};

/**
 * This is in effect -- EmbraceSQL, the fully configured and ready to
 * run in process engine. It can be used directly in process, or wrapped
 * in a server.
 */
export const EmbraceSQLEmbedded = async (
  rootContext?: InternalContext
): Promise<EmbeddedEngine> => {
  // the package itself has the configuration and is the root
  const internalContext = rootContext
    ? rootContext
    : await buildInternalContext(await loadConfiguration(__dirname));
  // at this point the context has the .directQueryExecutors and
  // can run a query to the database, but doesn't have handlers yet
  const handlerWrappedExecutors = decorateWithHandlers(internalContext);
  const transactionWrappedExecutors = decorateWithTransactions(
    internalContext,
    handlerWrappedExecutors
  );
  const typedExecutors = transactionWrappedExecutors;

  // outermost shell of calls in sql tree format -- this is for the embedded client .database.folder.module.sql syntax
  // and lets you call in a parameters --> results style, rather than the context --> context style
  const entryPointCallableDatabases = {
    default: {
      transactions: {
        begin: async (): Promise<void> => {
          return internalContext.databases.default.transactions.begin();
        },
        rollback: async (): Promise<void> => {
          return internalContext.databases.default.transactions.rollback();
        },
        commit: async (): Promise<void> => {
          return internalContext.databases.default.transactions.commit();
        },
        depth: (): number => {
          return internalContext.databases.default.transactions.depth();
        },
      },
      autocrud: {},
      hello: {
        sql: async (
          parameters: types.default_helloParameters
        ): Promise<types.default_helloRow[]> => {
          return (
            await typedExecutors.default_hello({
              parameters,
              results: [],
              databases: entryPointCallableDatabases,
            })
          ).results;
        },
      },
    },
  };

  // this is the 'outermost' shell of calls -- entry points into the engine from a server
  // this is in the context --> context style used for the server processes and event handlers
  const entryPoints = {
    // database default
    default_hello: {
      executor: async (
        context: types.default_helloContext
      ): Promise<types.default_helloContext> => {
        context.databases = entryPointCallableDatabases;
        return transactionWrappedExecutors.default_hello(context);
      },
      sqlModule: internalContext.databases.default.sqlModules.default_hello,
    },
  };

  return {
    configuration: internalContext.configuration,
    databases: entryPointCallableDatabases,
    entryPoints,
  };
};
"
`;

exports[`CLI initializes 1`] = `Array []`;

exports[`CLI initializes 2`] = `
Object {
  "stderr": Array [],
  "stdout": Array [],
}
`;

exports[`CLI migrates 1`] = `
"# THIS FILE IS GENERATED -- edits will be lost

openapi: 3.0.0
info:
  title: --
  description: --
  version: --

paths:
  /default/hello:
    get:
      operationId: get__default_hello
      description: Read data
      responses:
        \\"200\\":
          description: Sucess
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    hello_world:
                      type: string
    post:
      operationId: post__default_hello
      description: Read data
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        \\"200\\":
          description: Sucess
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    hello_world:
                      type: string
"
`;
