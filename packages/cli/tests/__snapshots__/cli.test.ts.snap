// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CLI generates an embedded client 1`] = `
"import {
  buildInternalContext,
  loadConfiguration,
  InternalContext,
  withTransaction,
} from \\"@embracesql/engine\\";
import * as types from \\"./context\\";

type EmbeddedEngine = types.HasEntryPoints &
  types.SQLModuleTree &
  types.HasConfiguration;

/**
 * This is in effect -- EmbraceSQL, the fully configured and ready to
 * run in process engine. It can be used directly in process, or wrapped
 * in a server.
 */
export const EmbraceSQLEmbedded = async (
  rootContext?: InternalContext
): Promise<EmbeddedEngine> => {
  // the package itself has the configuration and is the root
  const internalContext = rootContext
    ? rootContext
    : await buildInternalContext(await loadConfiguration(__dirname));
  // at this point the context has the .directQueryExecutors and
  // can run a query to the database, but doesn't have handlers yet
  const handlerWrappedExecutors = types.SQLModuleExecutorsWithHandlers(
    internalContext
  );

  // here is where things get tricky -- the context can have a database map to
  // call back into databases -- this is how a handler can call another query
  const handlerCallableDatabases = {
    default: {
      transactions: {
        begin: async (): Promise<void> => {
          return internalContext.databases.default.transactions.begin();
        },
        rollback: async (): Promise<void> => {
          return internalContext.databases.default.transactions.rollback();
        },
        commit: async (): Promise<void> => {
          return internalContext.databases.default.transactions.commit();
        },
        depth: (): number => {
          return internalContext.databases.default.transactions.depth();
        },
      },
      hello: {
        sql: async (
          parameters: types.default_helloParameters
        ): Promise<types.default_helloRow[]> => {
          return (
            await handlerWrappedExecutors.default_hello({
              parameters,
              results: [],
              databases: handlerCallableDatabases,
            })
          ).results;
        },
      },
    },
  };
  // and entry points executors -- these are transaction wrapped -- so these
  // are outer-most
  const entryPointExecutors = {
    // database default
    default_hello: async (
      context: types.default_helloContext
    ): Promise<types.default_helloContext> => {
      return withTransaction(
        internalContext.databases.default,
        handlerWrappedExecutors.default_hello,
        context
      );
    },
  };

  // this is the 'outermost' shell of calls -- entry points into the engine from a server
  const entryPoints = {
    // database default
    default_hello: {
      executor: async (
        context: types.default_helloContext
      ): Promise<types.default_helloContext> => {
        context.databases = handlerCallableDatabases;
        return entryPointExecutors.default_hello(context);
      },
      canModifyData: false,
    },
  };

  // outermost shell of calls in sql tree format -- this is for the embedded client .database.folder.module.sql syntax
  const entryPointCallableDatabases = {
    default: {
      transactions: {
        begin: async (): Promise<void> => {
          return internalContext.databases.default.transactions.begin();
        },
        rollback: async (): Promise<void> => {
          return internalContext.databases.default.transactions.rollback();
        },
        commit: async (): Promise<void> => {
          return internalContext.databases.default.transactions.commit();
        },
        depth: (): number => {
          return internalContext.databases.default.transactions.depth();
        },
      },
      hello: {
        sql: async (
          parameters: types.default_helloParameters
        ): Promise<types.default_helloRow[]> => {
          return (
            await entryPointExecutors.default_hello({
              parameters,
              results: [],
              databases: handlerCallableDatabases,
            })
          ).results;
        },
      },
    },
  };

  return {
    configuration: internalContext.configuration,
    databases: entryPointCallableDatabases,
    entryPoints,
  };
};
"
`;

exports[`CLI initializes 1`] = `Array []`;

exports[`CLI initializes 2`] = `
Object {
  "stderr": Array [],
  "stdout": Array [],
}
`;

exports[`CLI migrates 1`] = `
"# THIS FILE IS GENERATED -- edits will be lost

openapi: 3.0.0
info:
  title: --
  description: --
  version: --

paths:
  /default/hello:
    get:
      operationId: get__default_hello
      description: Read data
      responses:
        \\"200\\":
          description: Sucess
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    hello_world:
                      type: string
    post:
      operationId: post__default_hello
      description: Read data
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        \\"200\\":
          description: Sucess
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    hello_world:
                      type: string
"
`;
