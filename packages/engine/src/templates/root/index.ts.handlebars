---
to: "{{configuration.embraceSQLRoot}}/index.ts"
---

import { buildInternalContext, loadConfiguration, InternalContext } from "@embracesql/engine";
import * as types from "./context";

type EmbeddedEngine = types.HasContextualSQLModuleExecutors & types.SQLModuleTree;

/**
* This is in effect -- EmbraceSQL, the fully configured and ready to
* run in process engine. It can be used directly in process, or wrapped
* in a server.
*/
export const EmbraceSQLEmbedded = async (rootContext ?: InternalContext) : Promise<EmbeddedEngine> => {
  // the package itself has the configuration and is the root
  const context = rootContext ? 
      rootContext :
      await buildInternalContext(await loadConfiguration(__dirname));
  // at this point the context has the .directQueryExecutors and
  // can run a query to the database, but doesn't have handlers yet
  const handlerWrappedExecutors = types.SQLModuleExecutorsWithHandlers(context);
  // here is where things get tricky -- the context can have a database map too
  // but it isn't built yet -- time for some ... self referential code -- we're
  // making the databases and using the databases in the functions too
  const databases = {
    {{#eachInMap databases}}
      {{@key}}: {
      {{#treeAMap value.SQLModules database=value}}
        {{#each value}}
        {{> moduleTree this database=@database }}
        {{/each}}
      {{/treeAMap}}
      },
    {{/eachInMap}}
  }; 
  // and contextual named handlers -- these are used by http server wrappers
  const contextualSQLModuleExecutors = {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules}}
      {{value.contextName}}:  async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
        context.databases = databases;
        return handlerWrappedExecutors.{{value.contextName}}(context);
      },
    {{/eachInMap}}
    {{/eachInMap}}
  };
  // map of our read only methods
  const readOnlyContextualSQLModuleExecutors = {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules}}
      {{#if context.canModifyData}}
      {{else}}
      {{value.contextName}}:  async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
        context.databases = databases;
        return handlerWrappedExecutors.{{value.contextName}}(context);
      },
      {{/if}}
    {{/eachInMap}}
    {{/eachInMap}}

  };
  return {
    ...context, 
    databases, 
    contextualSQLModuleExecutors, 
    readOnlyContextualSQLModuleExecutors
  };
}

{{#*inline "moduleTree"}}
{{name}}: {
  {{#if value}}
  sql: async (parameters: types.{{value.contextName}}Parameters) : Promise<types.{{value.contextName}}Row[]> => {
    return (await handlerWrappedExecutors.{{value.contextName}}({parameters, results: [], databases})).results;
  }
  {{/if}}
  {{#each children}}
    {{> moduleTree this database=database}}
  {{/each}}
},
{{/inline}}