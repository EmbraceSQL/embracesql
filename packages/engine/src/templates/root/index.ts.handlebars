---
to: "{{configuration.embraceSQLRoot}}/index.ts"
---

import { buildInternalContext, loadConfiguration, InternalContext, withTransaction } from "@embracesql/engine";
import * as types from "./context";

type EmbeddedEngine = types.HasEntryPoints & types.SQLModuleTree & types.HasConfiguration & types.Closeable;

// each SQL Module has a direct execution decorator  -- this just talks to the database
// this attaches handlers both before and after wrapping the direct executor
// this ends up being a decorated map of handler+query execution capability
// autocrud is a little different, there are no handlers to load up from disk
// so this is a strong type wrapping
export const decorateWithHandlers = (rootContext: InternalContext) => {
  return {
  {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.sqlModules}}
      {{value.contextName}}:  async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
        const {afterError} = require("./{{value.restPath}}.sql.afterError");
        try {
          {{#each value.beforeHandlerPaths}}
          const before{{@index}} = require("./{{this}}/before").before;
          await before{{@index}}(context);
          {{/each}}
          const before = require("./{{value.restPath}}.sql.before").before;
          await before(context);
          const executor = rootContext.sqlModuleExecutors.{{value.contextName}}.executor;
          const results = executor ? (await executor(context)).results : [];
          context.results = results as types.{{value.contextName}}Row[];
          const after = require("./{{value.restPath}}.sql.after").after;
          await after(context);
          {{#each value.afterHandlerPaths}}
          const after{{@index}} = require("./{{this}}/after").after;
          await after{{@index}}(context);
          {{/each}}
          return context;
        } catch (error) {
          context.error = error;
          if (afterError) afterError(context);
          throw error;
        }
      },
    {{/eachInMap}}
    {{#eachInMap value.autocrudModules}}
      {{value.contextName}}:  async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
          const executor = rootContext.autocrudModuleExecutors.{{value.contextName}}.executor;
          const results = executor ? (await executor(context)).results : [];
          context.results = results as types.{{value.contextName}}Row[];
          return context;
      },
    {{/eachInMap}}
    {{/eachInMap}}
  }
};

// transaction wrappings very near the outside on each call
// this the the first 'real' execution layer
// so like - embedded engine -> entry point -> transactionwrapped
export const decorateWithTransactions = (
  rootContext: InternalContext, 
  innerExecutors: types.ExecutorMap) => {
    return {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.sqlModules database=@key}}
      {{value.contextName}}:  
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
            return withTransaction(
              rootContext.databases.{{@database}}, 
              innerExecutors.{{value.contextName}}, 
              context);
          },
    {{/eachInMap}}
    {{#eachInMap value.autocrudModules database=@key}}
      {{value.contextName}}:  
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
            return withTransaction(
              rootContext.databases.{{@database}}, 
              innerExecutors.{{value.contextName}}, 
              context);
          },
    {{/eachInMap}}
    {{/eachInMap}}
    };
};

// EmbraceSQL supports array valued parameter sets, as well as single sets of parameters
// which can result in a result set -- an array or rows -- or a single record / row
// this mapping deals with cardinality, treating arrays of 1 item as a single item
export const decorateWithCardinality = (
  innerExecutors: types.ExecutorMap) => {
    return {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.sqlModules database=@key}}
      {{value.contextName}}:  
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
              context.parameters = context?.parameters?.length === 1 ? context.parameters[0] : context.parameters;
              await innerExecutors.{{value.contextName}}(context);
              context.results = context?.results?.length === 1 ? context.results[0] : context.results;
              return context;
          },
    {{/eachInMap}}
    {{#eachInMap value.autocrudModules database=@key}}
      {{value.contextName}}:  
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
              context.parameters = context?.parameters?.length === 1 ? context.parameters[0] : context.parameters;
              await innerExecutors.{{value.contextName}}(context);
              context.results = context?.results?.length === 1 ? context.results[0] : context.results;
              return context;
          },
    {{/eachInMap}}
    {{/eachInMap}}
    };
};

/**
* This is in effect -- EmbraceSQL, the fully configured and ready to
* run in process engine. It can be used directly in process, or wrapped
* in a server.
*/
export const EmbraceSQLEmbedded = async (rootContext?: InternalContext) : Promise<EmbeddedEngine> => {
  // the package itself has the configuration and is the root
  const internalContext = rootContext ? 
      rootContext :
      await buildInternalContext(await loadConfiguration(__dirname));
  // at this point the context has the .directQueryExecutors and
  // can run a query to the database, but doesn't have handlers yet
  const handlerWrappedExecutors = decorateWithHandlers(internalContext);
  const transactionWrappedExecutors = decorateWithTransactions(internalContext, handlerWrappedExecutors);
  const typedExecutors = decorateWithCardinality(transactionWrappedExecutors);

  // outermost shell of calls in sql tree format -- this is for the embedded client .database.folder.module.sql syntax
  // and lets you call in a parameters --> results style, rather than the context --> context style
  const entryPointCallableDatabases = {
    {{#eachInMap databases}}
      {{@key}}: {
        transactions: {
          begin: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.begin();
          },
          rollback: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.rollback();
          },
          commit: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.commit();
          },
          depth: () : number => {
            return internalContext.databases.{{@key}}.transactions.depth();
          }
        },
        autocrud: {
        {{#treeAMap value.autocrudModules database=value handlerMap="typedExecutors"}}
          {{#each value}}
          {{> moduleTree this database=@database }}
          {{/each}}
        {{/treeAMap}}
        },
      {{#treeAMap value.sqlModules database=value handlerMap="typedExecutors"}}
        {{#each value}}
        {{> moduleTree this database=@database }}
        {{/each}}
      {{/treeAMap}}
      },
    {{/eachInMap}}
  }; 


  // this is the 'outermost' shell of calls -- entry points into the engine from a server
  // this is in the context --> context style used for the server processes and event handlers
  const entryPoints = {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.sqlModules database=@key}}
      {{value.contextName}}:  {
        executor:
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
            context.databases = entryPointCallableDatabases;
            return transactionWrappedExecutors.{{value.contextName}}(context);
          },
        sqlModule: internalContext.databases.{{@database}}.sqlModules.{{value.contextName}},
      },
    {{/eachInMap}}
    {{#eachInMap value.autocrudModules database=@key}}
      {{value.contextName}}:  {
        executor:
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
            context.databases = entryPointCallableDatabases;
            return transactionWrappedExecutors.{{value.contextName}}(context);
          },
        autocrudModule: internalContext.databases.{{@database}}.autocrudModules.{{value.contextName}},
      },
    {{/eachInMap}}
    {{/eachInMap}}
  };



  return {
    configuration: internalContext.configuration,
    databases: entryPointCallableDatabases, 
    entryPoints,
    close: internalContext.close,
  };
}

{{#*inline "moduleTree"}}
  {{#if children.length}}
  {{name}}: {
  {{#each children}}
    {{> moduleTree this database=database}}
  {{/each}}
  },
  {{else}}
  {{name}}: async (...parameters: types.{{value.contextName}}ParameterSet[]) : Promise<types.{{value.contextName}}Result> => {
      const context = 
        await {{@handlerMap}}.{{value.contextName}}({
          parameters: parameters,
          results: [], 
          databases: entryPointCallableDatabases
        });
      return context.results;
  },
  {{/if}}
{{/inline}}
