---
to: "{{configuration.embraceSQLRoot}}/index.ts"
---

import { buildInternalContext, loadConfiguration, InternalContext } from "@embracesql/engine";
import * as types from "./context";

type EmbeddedEngine = types.HasContextualSQLModuleExecutors & types.SQLModuleTree & types.HasConfiguration;

/**
* This is in effect -- EmbraceSQL, the fully configured and ready to
* run in process engine. It can be used directly in process, or wrapped
* in a server.
*/
export const EmbraceSQLEmbedded = async (rootContext ?: InternalContext) : Promise<EmbeddedEngine> => {
  // the package itself has the configuration and is the root
  const context = rootContext ? 
      rootContext :
      await buildInternalContext(await loadConfiguration(__dirname));
  // at this point the context has the .directQueryExecutors and
  // can run a query to the database, but doesn't have handlers yet
  const handlerWrappedExecutors = types.SQLModuleExecutorsWithHandlers(context);
  // here is where things get tricky -- the context can have a database map to
  // call back into databases -- so this is a forward declaration of that map
  const databases = {
    {{#eachInMap databases}}
      {{@key}}: {
        transactions: {
          begin: async () : Promise<void> => {
            return context.databases.{{@key}}.transactions.begin();
          },
          rollback: async () : Promise<void> => {
            return context.databases.{{@key}}.transactions.rollback();
          },
          commit: async () : Promise<void> => {
            return context.databases.{{@key}}.transactions.commit();
          },
        },
      {{#treeAMap value.SQLModules database=value}}
        {{#each value}}
        {{> moduleTree this database=@database }}
        {{/each}}
      {{/treeAMap}}
      },
    {{/eachInMap}}
  }; 
  // and contextual named handlers -- this gives you access to call back into the databases from within a handler
  // this is the 'outermost' shell of calls
  const contextualSQLModuleExecutors = {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules}}
      {{value.contextName}}:  async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
        context.databases = databases;
        return handlerWrappedExecutors.{{value.contextName}}(context);
      },
    {{/eachInMap}}
    {{/eachInMap}}
  };
  // map of our read only methods -- this is used to figure out GET/POST
  const readOnlyContextualSQLModuleExecutors = {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules}}
      {{#if value.canModifyData}}
      // {{value.contextName}} is a mutation and does not get GET
      {{else}}
      {{value.contextName}}: contextualSQLModuleExecutors.{{value.contextName}},
      {{/if}}
    {{/eachInMap}}
    {{/eachInMap}}

  };
  return {
    configuration: context.configuration,
    databases, 
    contextualSQLModuleExecutors, 
    readOnlyContextualSQLModuleExecutors
  };
}

{{#*inline "moduleTree"}}
{{name}}: {
  {{#if value}}
  sql: async (parameters: types.{{value.contextName}}Parameters) : Promise<types.{{value.contextName}}Row[]> => {
    return (await handlerWrappedExecutors.{{value.contextName}}({parameters, results: [], databases})).results;
  }
  {{/if}}
  {{#each children}}
    {{> moduleTree this database=database}}
  {{/each}}
},
{{/inline}}
