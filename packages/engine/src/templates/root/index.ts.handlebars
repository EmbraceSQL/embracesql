---
to: "{{configuration.embraceSQLRoot}}/index.ts"
---

import { buildInternalContext, loadConfiguration, InternalContext, withTransaction } from "@embracesql/engine";
import * as types from "./context";

type EmbeddedEngine = types.HasEntryPoints & types.SQLModuleTree & types.HasConfiguration;

/**
* This is in effect -- EmbraceSQL, the fully configured and ready to
* run in process engine. It can be used directly in process, or wrapped
* in a server.
*/
export const EmbraceSQLEmbedded = async (rootContext ?: InternalContext) : Promise<EmbeddedEngine> => {
  // the package itself has the configuration and is the root
  const internalContext = rootContext ? 
      rootContext :
      await buildInternalContext(await loadConfiguration(__dirname));
  // at this point the context has the .directQueryExecutors and
  // can run a query to the database, but doesn't have handlers yet
  const handlerWrappedExecutors = types.SQLModuleExecutorsWithHandlers(internalContext);

  // here is where things get tricky -- the context can have a database map to
  // call back into databases -- this is how a handler can call another query
  const handlerCallableDatabases = {
    {{#eachInMap databases}}
      {{@key}}: {
        transactions: {
          begin: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.begin();
          },
          rollback: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.rollback();
          },
          commit: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.commit();
          },
          depth: () : number => {
            return internalContext.databases.{{@key}}.transactions.depth();
          }
        },
      {{#treeAMap value.SQLModules database=value handlerMap="handlerWrappedExecutors"}}
        {{#each value}}
        {{> moduleTree this database=@database }}
        {{/each}}
      {{/treeAMap}}
      },
    {{/eachInMap}}
  }; 
  // and entry points executors -- these are transaction wrapped -- so these
  // are outer-most
  const entryPointExecutors = {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules database=@key}}
      {{value.contextName}}:  
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
            return withTransaction(
              internalContext.databases.{{@database}}, 
              handlerWrappedExecutors.{{value.contextName}}, 
              context);
          },
    {{/eachInMap}}
    {{/eachInMap}}
  };

  // this is the 'outermost' shell of calls -- entry points into the engine from a server
  const entryPoints = {
    {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules}}
      {{value.contextName}}:  {
        executor:
          async (context: types.{{value.contextName}}Context) : Promise<types.{{value.contextName}}Context> => {
            context.databases = handlerCallableDatabases;
            return entryPointExecutors.{{value.contextName}}(context);
          },
        canModifyData:
          {{#if value.canModifyData}}
            true,
          {{else}}
            false,
          {{/if}}
      },
    {{/eachInMap}}
    {{/eachInMap}}
  };

  // outermost shell of calls in sql tree format -- this is for the embedded client .database.folder.module.sql syntax
  const entryPointCallableDatabases = {
    {{#eachInMap databases}}
      {{@key}}: {
        transactions: {
          begin: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.begin();
          },
          rollback: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.rollback();
          },
          commit: async () : Promise<void> => {
            return internalContext.databases.{{@key}}.transactions.commit();
          },
          depth: () : number => {
            return internalContext.databases.{{@key}}.transactions.depth();
          }
        },
      {{#treeAMap value.SQLModules database=value handlerMap="entryPointExecutors"}}
        {{#each value}}
        {{> moduleTree this database=@database }}
        {{/each}}
      {{/treeAMap}}
      },
    {{/eachInMap}}
  }; 

  return {
    configuration: internalContext.configuration,
    databases: entryPointCallableDatabases, 
    entryPoints
  };
}

{{#*inline "moduleTree"}}
{{name}}: {
  {{#if value}}
  sql: async (parameters: types.{{value.contextName}}Parameters) : Promise<types.{{value.contextName}}Row[]> => {
    return (
      await {{@handlerMap}}.{{value.contextName}}({parameters, results: [], databases: handlerCallableDatabases})
    ).results;
  }
  {{/if}}
  {{#each children}}
    {{> moduleTree this database=database}}
  {{/each}}
},
{{/inline}}
