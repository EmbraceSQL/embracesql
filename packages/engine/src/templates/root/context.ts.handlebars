---
to: "{{configuration.embraceSQLRoot}}/context.ts"
---

/**
* THIS FILE IS GENERATED -- edits will be lost
*/

{{> shared-context.ts}}

// Generation starts here

// tree structure of the entire set of databases and handlers
export type SQLModuleTree = {
  databases: {
  {{#eachInMap databases}}
    {{@key}}: {
      transactions: DatabaseTransactions,
      {{#treeAMap value.SQLModules database=value}}
        {{#each value}}
        {{> moduleTree this database=@database }}
        {{/each}}
      {{/treeAMap}}
      autocrud: {
      {{#treeAMap value.AutocrudModules database=value}}
        {{#each value}}
        {{> moduleTree this database=@database }}
        {{/each}}
      {{/treeAMap}}
      },
    },
  {{/eachInMap}}
  }
};
{{#*inline "moduleTree"}}
{{name}}: {
  {{#if value}}
  sql: (parameters: {{value.contextName}}Parameters) => Promise<{{value.contextName}}Row[]>;
  {{/if}}
  {{#each children}}
    {{> moduleTree this database=database}}
  {{/each}}
},
{{/inline}}

// parameters, result row, and context types
{{#eachInMap databases}}
// database {{@key}}
{{#eachInMap value.SQLModules}}
// sql module {{@key}} {{value}}
{{> moduleMetadata module=value}}
{{/eachInMap}}
{{#eachInMap value.AutocrudModules}}
// autocrud module {{@key}} {{value}}
{{> moduleMetadata module=value}}
{{/eachInMap}}
{{/eachInMap}}

// handle a folder, these use the base types for rows and parameters
// to allow them to be maximally generic
export type FolderHandler = (context: Context<SQLRow>) => Promise<Context<SQLRow>>;

{{#*inline "moduleMetadata"}}

// module {{module.contextName}} parameters, row type, and context type
{{> resultsetMetadata module}}
{{> parametersMetadata module}}
export type {{module.contextName}}Context = 
  SQLModuleTree & Context<{{module.contextName}}Row> & { 
    parameters: {{module.contextName}}Parameters
  };
export type {{module.contextName}}Handler = 
  (context: {{module.contextName}}Context) => Promise<{{module.contextName}}Context>;
{{/inline}}

{{#*inline "resultsetMetadata"}}
export type {{contextName}}Row = 
SQLRow & {
  {{#each resultsetMetadata}}
    {{name}}: {{type}}
  {{/each}}
};
{{/inline}}

{{#*inline "parametersMetadata"}}
export type {{contextName}}Parameters = 
SQLParameters & {
  {{#each namedParameters}}
    {{name}}: {{type}}
  {{/each}}
};
{{/inline}}


// each SQL Module has a direct execution decorator  -- this just talks to the database
// this attaches handlers both before and after wrapping the direct executor
// this ends up being a decorated map of handler+query execution capability
export const SQLModuleExecutorsWithHandlers = ({directQueryExecutors}: HasSQLModuleDirectExecutors) => {
  return {
  {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules}}
      {{value.contextName}}:  async (context: {{value.contextName}}Context) : Promise<{{value.contextName}}Context> => {
        const {afterError} = require("./{{value.restPath}}.sql.afterError");
        try {
          {{#each value.beforeHandlerPaths}}
          const before{{@index}} = require("./{{this}}/before").before;
          await before{{@index}}(context);
          {{/each}}
          const before = require("./{{value.restPath}}.sql.before").before;
          await before(context);
          const executor = directQueryExecutors["{{value.contextName}}"];
          const results = executor ? await executor(context.parameters) : [];
          context.results = results as {{value.contextName}}Row[];
          const after = require("./{{value.restPath}}.sql.after").after;
          await after(context);
          {{#each value.afterHandlerPaths}}
          const after{{@index}} = require("./{{this}}/after").after;
          await after{{@index}}(context);
          {{/each}}
          return context;
        } catch (error) {
          context.error = error;
          if (afterError) afterError(context);
          throw error;
        }
      },
    {{/eachInMap}}
    {{/eachInMap}}
  }
};

// autocrud is a little different, there are no handlers to load up from disk
// so this is a strong type wrapping
export const AutocrudExecutorsWithoutHandlers = ({autocrudExecutors}: HasAutocrudExecutors) => {
  // force Use
  autocrudExecutors.toString();
  return {
  {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.AutocrudModules}}
      {{value.contextName}}:  async (context: {{value.contextName}}Context) : Promise<{{value.contextName}}Context> => {
          const executor = autocrudExecutors["{{value.contextName}}"];
          const results = executor ? await executor(context.parameters) : [];
          context.results = results as {{value.contextName}}Row[];
          return context;
      },
    {{/eachInMap}}
    {{/eachInMap}}
  }
};