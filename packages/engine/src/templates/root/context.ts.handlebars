---
to: "{{configuration.embraceSQLRoot}}/context.ts"
---
/* eslint-disable @typescript-eslint/camelcase */

/**
* THIS FILE IS GENERATED -- edits will be lost
*/

{{> shared-context.ts}}

// Generation starts here

// tree structure of the entire set of databases and handlers
export type SQLModuleTree = {
  databases: {
  {{#eachInMap databases}}
    {{@key}}: {
      transactions: DatabaseTransactions,
    {{#treeAMap value.SQLModules database=value}}
      {{#each value}}
      {{> moduleTree this database=@database }}
      {{/each}}
    {{/treeAMap}}
    },
  {{/eachInMap}}
  }
};
{{#*inline "moduleTree"}}
{{name}}: {
  {{#if value}}
  sql: (parameters: {{value.contextName}}Parameters) => Promise<{{value.contextName}}Row[]>;
  {{/if}}
  {{#each children}}
    {{> moduleTree this database=database}}
  {{/each}}
},
{{/inline}}

// each SQLModule gets its own unique context type
{{#eachInMap databases}}
// database {{@key}}
{{#eachInMap value.SQLModules}}
// module {{value.restPath}}
{{> resultsetMetadata value}}
{{> parametersMetadata value}}
export type {{value.contextName}}Context = 
  SQLModuleTree & Context<{{value.contextName}}Row> & { 
    parameters: {{value.contextName}}Parameters
  };
export type {{value.contextName}}Handler = 
  (context: {{value.contextName}}Context) => Promise<{{value.contextName}}Context>;
{{/eachInMap}}
{{/eachInMap}}

// handle a folder, thse use the base types for rows and parameters
// to allow them to be maximally generic
export type FolderHandler = (context: Context<SQLRow>) => Promise<Context<SQLRow>>;


// each sql module will have a row return type, adding required properties to the base
{{#*inline "resultsetMetadata"}}
export type {{contextName}}Row = 
SQLRow & {
  {{#each resultsetMetadata}}
    {{name}}: {{type}}
  {{/each}}
};
{{/inline}}

// each sql module will have a set of parameters, adding required parameters to the base
{{#*inline "parametersMetadata"}}
export type {{contextName}}Parameters = 
SQLParameters & {
  {{#each namedParameters}}
    {{name}}: {{type}}
  {{/each}}
};
{{/inline}}


// each SQL Module has a direct execution decorator  -- this just talks to the database
// this attaches handlers both before and after wrapping the direct executor
// this ends up being a decorated map of handler+query execution capability
export const SQLModuleExecutorsWithHandlers = ({directQueryExecutors}: SQLModuleDirectExecutors) => {
  return {
  {{#eachInMap databases}}
    // database {{@key}}
    {{#eachInMap value.SQLModules}}
      {{value.contextName}}:  async (context: {{value.contextName}}Context) : Promise<{{value.contextName}}Context> => {
        const {afterError} = require("./{{value.restPath}}.sql.afterError");
        try {
          {{#each value.beforeHandlerPaths}}
          const before{{@index}} = require("./{{this}}/before").before;
          await before{{@index}}(context);
          {{/each}}
          const before = require("./{{value.restPath}}.sql.before").before;
          await before(context);
          const executor = directQueryExecutors["{{value.contextName}}"];
          const results = executor ? await executor(context.parameters) : [];
          context.results = results as {{value.contextName}}Row[];
          const after = require("./{{value.restPath}}.sql.after").after;
          await after(context);
          {{#each value.afterHandlerPaths}}
          const after{{@index}} = require("./{{this}}/after").after;
          await after{{@index}}(context);
          {{/each}}
          return context;
        } catch (error) {
          context.error = error;
          if (afterError) afterError(context);
          throw error;
        }
      },
    {{/eachInMap}}
    {{/eachInMap}}
  }
};

export type SQLModuleExecutorsWithHandlers_T = ReturnType<typeof SQLModuleExecutorsWithHandlers>;